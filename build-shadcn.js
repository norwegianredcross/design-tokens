const fs = require('fs');
const path = require('path');
const { converter } = require('culori');

// Helper to convert a hex color to an OKLCH string for shadcn
const toOklchString = (hex) => {
  if (!hex || typeof hex !== 'string' || !hex.startsWith('#')) {
    return '0% 0 0'; // Return a default/invalid value
  }
  const oklch = converter('oklch')(hex);
  return `${(oklch.l * 100).toFixed(2)}% ${oklch.c.toFixed(4)} ${oklch.h?.toFixed(2) || 0}`;
};

// --- CONFIGURATION ---
// This map connects your Tokens Studio names to the shadcn/ui names.
// You can adjust this if your token names change.
const TOKEN_MAP = {
  background: '--ds-color-neutral-background-default',
  foreground: '--ds-color-neutral-text-default',
  card: '--ds-color-neutral-surface-default',
  'card-foreground': '--ds-color-neutral-text-default',
  popover: '--ds-color-neutral-surface-default',
  'popover-foreground': '--ds-color-neutral-text-default',
  primary: '--ds-color-primary-base-default',
  'primary-foreground': '--ds-color-primary-base-contrast-default',
  secondary: '--ds-color-neutral-base-default',
  'secondary-foreground': '--ds-color-neutral-base-contrast-default',
  muted: '--ds-color-neutral-surface-tinted',
  'muted-foreground': '--ds-color-neutral-text-subtle',
  accent: '--ds-color-primary-surface-active',
  'accent-foreground': '--ds-color-primary-text-default',
  destructive: '--ds-color-danger-base-default',
  'destructive-foreground': '--ds-color-danger-base-contrast-default',
  border: '--ds-color-neutral-border-default',
  input: '--ds-color-neutral-border-subtle',
  ring: '--ds-color-focus-outer',
  radius: '--ds-border-radius-base', // Special case for radius
};

/**
 * Parses a block of CSS text to extract CSS variables.
 * @param {string} cssBlock - The string of CSS to parse.
 * @returns {Map<string, string>} A map of variable names to their values.
 */
function parseCssVariables(cssBlock) {
  const variables = new Map();
  const regex = /(--[\w-]+):\s*([^;]+);/g;
  let match;
  while ((match = regex.exec(cssBlock)) !== null) {
    variables.set(match[1].trim(), match[2].trim());
  }
  return variables;
}

/**
 * Main transformation function.
 */
function transformTokens() {
  console.log('üöÄ Starting token transformation...');

  const inputPath = path.join(__dirname, 'design-tokens-build', 'theme.css');
  const outputPath = path.join(__dirname, 'design-tokens-build', 'shadcn-theme.css');

  if (!fs.existsSync(inputPath)) {
    console.error(`‚ùå Error: Input file not found at ${inputPath}`);
    return;
  }

  // 1. Read and split the source CSS into light and dark sections
  const sourceCss = fs.readFileSync(inputPath, 'utf8');
  const lightThemeCss = sourceCss.split('@layer ds.theme.color-scheme.light')[1]?.split('@layer')[0] || '';
  const darkThemeCss = sourceCss.split('@layer ds.theme.color-scheme.dark')[1]?.split('@layer')[0] || '';
  const semanticCss = sourceCss.split('@layer ds.theme.semantic')[1]?.split('@layer')[0] || '';
  
  // 2. Parse variables from each section
  const lightVars = parseCssVariables(lightThemeCss);
  const darkVars = parseCssVariables(darkThemeCss);
  const semanticVars = parseCssVariables(semanticCss);

  // 3. Generate the new CSS content
  let output = `/* This file is automatically generated. Do not edit directly. */\n`;
  output += `@import "tailwindcss";\n`;
  output += `@import "tw-animate-css";\n\n`; // or "tailwindcss-animate"
  
  // Add @theme block
  output += `@custom-variant dark (&:is(.dark *));\n\n`;
  output += `@theme inline {\n`;
  for (const key in TOKEN_MAP) {
    if (key !== 'radius') {
        output += `  --color-${key}: var(--${key});\n`;
    }
  }
  output += `  --radius: var(--radius);\n`;
  output += `  --radius-sm: calc(var(--radius) - 2px);\n`;
  output += `  --radius-lg: calc(var(--radius) + 2px);\n`;
  output += `}\n\n`;
  
  // --- :root (Light Theme) ---
  output += `:root {\n`;
  for (const [shadcnName, dsName] of Object.entries(TOKEN_MAP)) {
    if (shadcnName === 'radius') continue;
    const hexValue = lightVars.get(dsName);
    output += `  --${shadcnName}: oklch(${toOklchString(hexValue)}); /* ${hexValue} */\n`;
  }
  output += `  --radius: ${semanticVars.get(TOKEN_MAP.radius) || '0.25rem'};\n`;
  output += `}\n\n`;

  // --- .dark (Dark Theme) ---
  output += `.dark {\n`;
  for (const [shadcnName, dsName] of Object.entries(TOKEN_MAP)) {
    if (shadcnName === 'radius') continue;
    const hexValue = darkVars.get(dsName);
    output += `  --${shadcnName}: oklch(${toOklchString(hexValue)}); /* ${hexValue} */\n`;
  }
  output += `  --radius: ${semanticVars.get(TOKEN_MAP.radius) || '0.25rem'};\n`;
  output += `}\n\n`;
  
  // --- @layer base ---
  output += `@layer base {\n`;
  output += `  * {\n    @apply border-border;\n  }\n`;
  output += `  body {\n    @apply bg-background text-foreground;\n  }\n`;
  output += `}\n`;

  // 4. Write the new file
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, output);

  console.log(`‚úÖ Successfully transformed tokens!`);
  console.log(`   Output file generated at: ${outputPath}`);
}

// Run the script
transformTokens();

